<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Elasticsearch(一)</title>
    <link href="/2020/03/25/article/"/>
    <url>/2020/03/25/article/</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><h3 id="1、Node-与-Cluste"><a href="#1、Node-与-Cluste" class="headerlink" title="1、Node 与 Cluste"></a>1、Node 与 Cluste</h3><p>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。</p><p>单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p><h3 id="2、-Index"><a href="#2、-Index" class="headerlink" title="2、 Index"></a>2、 Index</h3><p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。</p><p>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。</p><p>下面的命令可以查看当前节点的所有 Index。</p><pre><code class="bash">$ curl -X GET &#39;http://localhost:9200/_cat/indices?v&#39;</code></pre><h3 id="3、Document"><a href="#3、Document" class="headerlink" title="3、Document"></a>3、Document</h3><p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。</p><p>Document 使用 JSON 格式表示，下面是一个例子。</p><pre><code class="json">{  &quot;user&quot;: &quot;张三&quot;,  &quot;title&quot;: &quot;工程师&quot;,  &quot;desc&quot;: &quot;数据库管理&quot;}</code></pre><p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p><h3 id="4、-Type"><a href="#4、-Type" class="headerlink" title="4、 Type"></a>4、 Type</h3><p>Document 可以分组，比如<code>weather</code>这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。</p><p>不同的 Type 应该有相似的结构（schema），举例来说，<code>id</code>字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的<a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/mapping.html" target="_blank" rel="noopener">一个区别</a>。性质完全不同的数据（比如<code>products</code>和<code>logs</code>）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p><p>下面的命令可以列出每个 Index 所包含的 Type。</p><pre><code class="bash">$ curl &#39;localhost:9200/_mapping?pretty=true&#39;</code></pre><p>根据<a href="https://www.elastic.co/blog/index-type-parent-child-join-now-future-in-elasticsearch" target="_blank" rel="noopener">规划</a>，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。</p><h2 id="5、新建和删除-Index"><a href="#5、新建和删除-Index" class="headerlink" title="5、新建和删除 Index"></a>5、新建和删除 Index</h2><p>新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫<code>weather</code>的 Index。</p><pre><code class="bash">$ curl -X PUT &#39;localhost:9200/weather&#39;</code></pre><p>服务器返回一个 JSON 对象，里面的<code>acknowledged</code>字段表示操作成功。</p><pre><code class="json">{  &quot;acknowledged&quot;:true,  &quot;shards_acknowledged&quot;:true}</code></pre><p>然后，我们发出 DELETE 请求，删除这个 Index。</p><pre><code class="bash">$ curl -X DELETE &#39;localhost:9200/weather&#39;</code></pre><h2 id="四、中文分词设置"><a href="#四、中文分词设置" class="headerlink" title="四、中文分词设置"></a>四、中文分词设置</h2><p>首先，安装中文分词插件。这里使用的是 <a href="https://github.com/medcl/elasticsearch-analysis-ik/" target="_blank" rel="noopener">ik</a>，也可以考虑其他插件（比如 <a href="https://www.elastic.co/guide/en/elasticsearch/plugins/current/analysis-smartcn.html" target="_blank" rel="noopener">smartcn</a>）。</p><blockquote><pre><code class="javascript">$ ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip</code></pre></blockquote><p>上面代码安装的是5.5.1版的插件，与 Elastic 5.5.1 配合使用。</p><p>接着，重新启动 Elastic，就会自动加载这个新安装的插件。</p><p>然后，新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，下面的命令只针对本文。基本上，凡是需要搜索的中文字段，都要单独设置一下。</p><blockquote><pre><code class="bash">$ curl -X PUT &#39;localhost:9200/accounts&#39; -d &#39;{  &quot;mappings&quot;: {    &quot;person&quot;: {      &quot;properties&quot;: {        &quot;user&quot;: {          &quot;type&quot;: &quot;text&quot;,          &quot;analyzer&quot;: &quot;ik_max_word&quot;,          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;        },        &quot;title&quot;: {          &quot;type&quot;: &quot;text&quot;,          &quot;analyzer&quot;: &quot;ik_max_word&quot;,          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;        },        &quot;desc&quot;: {          &quot;type&quot;: &quot;text&quot;,          &quot;analyzer&quot;: &quot;ik_max_word&quot;,          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;        }      }    }  }}&#39;</code></pre></blockquote><p>上面代码中，首先新建一个名称为<code>accounts</code>的 Index，里面有一个名称为<code>person</code>的 Type。<code>person</code>有三个字段。</p><blockquote><ul><li>user</li><li>title</li><li>desc</li></ul></blockquote><p>这三个字段都是中文，而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。</p><p>Elastic 的分词器称为 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html" target="_blank" rel="noopener">analyzer</a>。我们对每个字段指定分词器。</p><blockquote><pre><code class="javascript">&quot;user&quot;: {  &quot;type&quot;: &quot;text&quot;,  &quot;analyzer&quot;: &quot;ik_max_word&quot;,  &quot;search_analyzer&quot;: &quot;ik_max_word&quot;}</code></pre></blockquote><p>上面代码中，<code>analyzer</code>是字段文本的分词器，<code>search_analyzer</code>是搜索词的分词器。<code>ik_max_word</code>分词器是插件<code>ik</code>提供的，可以对文本进行最大数量的分词。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java 设计模式(一)</title>
    <link href="/2020/03/06/java/"/>
    <url>/2020/03/06/java/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p> 每个类只能创建一个实例对象。Java Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。 使用Singleton的好处还在于可以节省内存，因为它限制了实例的个数，有利于Java垃圾回收（garbage collection）。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>1 控制资源的使用，通过线程同步来控制资源的并发访问；</li><li>2 控制实例产生的数量，达到节约资源的目的。</li><li>3 作为通信媒介使用，也就是数据共享，它可以在不建立直接关联的条件下，让多个不相关的两个线程或者进程之间实现通信。</li></ul><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p>饿汉-单例式 懒汉-单例式 静态内部类</p><h3 id="1-饿汉-单例式"><a href="#1-饿汉-单例式" class="headerlink" title="1.饿汉-单例式"></a>1.饿汉-单例式</h3><p>效率高，线程安全，但浪费内存；不管对象是否真的用到，都直接创建完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.定义私有静态变量，类型为类类型</span></span><br><span class="line">    <span class="comment">//直接创建好对象，不论到底会用到用不到，故称为饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">    <span class="comment">//2.定义私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.定义公共静态方法，返回私有静态变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-懒汉-单例式"><a href="#2-懒汉-单例式" class="headerlink" title="2.懒汉-单例式"></a>2.懒汉-单例式</h3><p>效率低，线程不安全，需要通过synchronize来保证线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.定义私有静态变量，类型为类类型,</span></span><br><span class="line">    <span class="comment">// 先不创建，等用到时再创建（正是由于等用到时才创建，故而才称为懒汉式）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//2.定义私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.定义公共静态方法，返回私有静态变量</span></span><br><span class="line">    <span class="comment">//public static Singleton2 getInstance()&#123;//线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">// 线程安全，通过synchronize保证线程安全</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3.静态内部类"></a>3.静态内部类</h3><p>效率高，线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.定义静态内部类，类里面有静态内部属性，为类类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">SingletonInnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton3 instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.定义私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.定义公共静态方法，返回内部类的静态常量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInnerClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p><p>&nbsp;<br>下一节开始学习工厂模式。。。。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
